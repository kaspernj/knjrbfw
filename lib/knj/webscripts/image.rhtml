<%
  #Support for the PHP-version... Comes handy when converting PHP to Ruby...
  if !_get["path"]
    trans = {
      "picture" => "path"
    }
    
    if _get["edgesize"]
      _get["rounded_corners"] = (_get["edgesize"].to_f / 3.0).to_i
    end
    
    if _get["edgeborder"]
      if _get["edgeborder"].length == 6
        _get["border_color"] = "##{_get["edgeborder"]}"
      else
        _get["border_color"] = _get["edbeborder"]
      end
    end
    
    if _get["edgeborder"]
      _get["border"] = 1
    end
    
    trans.each do |key, val|
      _get[val] = _get[key] if _get[key]
    end
  end
  
  
	idstr = Digest::MD5.hexdigest("#{_get["path"]}_#{_get["smartsize"].to_i}_#{_get["width"].to_i}_#{_get["height"].to_i}_#{_get["maxwidth"].to_i}_#{_get["maxheight"].to_i}_#{_get["rounded_corners"].to_i}_#{_get["border"].to_i}_#{_get["border_color"]}")
	
	if !_get["path"] or !File.exists?(_get["path"])
    print "File does not exist: '#{_get["path"]}'.\n"
    exit
  end
	
	time_orig = File.mtime(_get["path"])
	
	tmp_use = false
	tmp_write = false
	if $knj_webscripts_image_config
		tmp_use = true
		tmp_path = "#{$knj_webscripts_image_config["tmp_path"]}/#{idstr}"
		tmp_exists = File.exists?(tmp_path)
		tmp_write = true if !tmp_exists
		
		if !tmp_write and tmp_exists
			time_cache = File.mtime(tmp_path)
			
			if time_orig > time_cache
				tmp_write = true
			end
		end
	end
	
	if _get["force"] == "true" or _get["force"] == "1"
    force = true
  else
    force = false
  end
  
	notchanged = false
	
	if _httpsession.handler.modified_since and time_cache and _httpsession.handler.modified_since.utc.to_s == time_cache.utc.to_s
    notchanged = true
  elsif _httpsession.handler.modified_since and _httpsession.handler.modified_since.utc.to_s == time_orig.utc.to_s
    notchanged = true
  end
  
  if notchanged and !force
    _httpsession.resp.status = 304
    exit
  end
  
	if !tmp_use or tmp_write or force
    blob_cont = nil
    Knj::Process_meta.new("debug_err" => true) do |subproc|
      subproc.static("Object", "require", "rubygems")
      subproc.static("Object", "require", "#{File.dirname(Knj::Os.realpath(__FILE__))}/../../knjrbfw.rb")
      subproc.static("Object", "require", "knj/autoload")
      subproc.static("Dir", "chdir", File.dirname(__FILE__))
      
      list_proxy = subproc.proxy_from_static("Magick::Image", "read", _get["path"])
      pic = subproc.proxy_from_call(list_proxy, "first")
      #pic = Magick::Image.read(_get["path"]).first
      
      if !pic
        print "Could not open image from '#{_get["path"]}'."
        exit
      end
      
      pic._pm_send_noret("format=", "png")
      
      pic_columns = pic.columns
      pic_rows = pic.rows
      
      width = pic_columns
      height = pic_rows
      
      height = _get["height"].to_i if _get["height"]
      width = _get["width"].to_i if _get["width"]
      
      if _get["smartsize"]
        if pic_columns > pic_rows
          width = _get["smartsize"].to_i
          height = (pic_rows.to_f / (pic_columns.to_f / width.to_f)).to_i
        else
          height = _get["smartsize"].to_i
          width = (pic_columns.to_f / (pic_rows.to_f / height.to_f)).to_i
        end
      end
      
      if _get["maxwidth"]
        maxwidth = _get["maxwidth"].to_i
        
        if width > maxwidth
          height = (pic_rows.to_f / (pic_columns.to_f / maxwidth.to_f)).to_i
          width = maxwidth
        end
      end
      
      if _get["maxheight"]
        maxheight = _get["maxheight"].to_i
        
        if height > maxheight
          width = (pic_columns.to_f / (pic_rows.to_f / maxheight.to_f)).to_i
          height = maxheight
        end
      end
      
      if _get["width"] and _get["height"]
        width = _get["width"].to_i
        height = _get["height"].to_i
      end
      
      if height != pic_rows or width != pic_columns
        pic = subproc.proxy_from_call(pic, "resize_to_fit", width.to_i, height.to_i)
        #pic = pic.resize_to_fit(width.to_i, height.to_i)
      end
      
      if _get["rounded_corners"]
        args = {:img => pic, :radius => _get["rounded_corners"].to_i}
        
        if _get["border"] and _get["border_color"]
          args[:border] = _get["border"].to_i
          args[:border_color] = _get["border_color"]
        end
        
        #Spawn arguments-hash for Knj::Image.rounded_corners in subprocess.
        proxy_hash = subproc.new("{}", args)
        
        #Call rounded_corners with the proxy-hash.
        subproc.static_noret("Knj::Image", "rounded_corners", proxy_hash)
        #Knj::Image.rounded_corners(args)
      end
      
      blob_cont = pic.to_blob
    end
	end
	
	if tmp_write and blob_cont
    File.open(tmp_path, "w") do |fp|
      fp.write(blob_cont)
    end
	end
	
	if tmp_use
    _kas.header("Last-Modified", "#{time_orig.httpdate} GMT") if time_orig
		_kas.header("Content-Type", "image/png")
		_httpsession.force_content(File.new(tmp_path))
	else
    _kas.header("Last-Modified", "#{time_orig.httpdate} GMT") if time_orig
		_kas.header("Content-Type", "image/png")
		_httpsession.force_content(blob_cont)
	end
%>